React 

Single Page Apps

the problem with multipage apps with diff pages is that, when you go a specific page in that app,
 you'll have to download all the html files for that page.

 with react it downloads all js inside one html file making it more efficient and faster to navigate 


React Component

Props


JSX 

States
- are variables that holds data - can be a string, numbers
- react initally renders a component once. It doesn't know it requires to re render to show new values
of a variable by default
Import useState Hook-a function
import { useState } from 'react'
- we don't mutate states directly eg. like in js let name = [] cont person = "nick" name.push(person)
in states, we use the function that is set to mutate the value

declare State
const [count, setCount] = useState(0) // sets count to 0
- state is a variable that when it changes, react will be notified to re render the page


Events 
- Something that happens as a response to something else

Component Lifecycle
- how everything happens from the birth of a component to the death of a component
Stages in React Lifecycle
1. Mounting Stage
2. Updating Stage
3. Unmonting Stage

useEffect hook
- most important hook in react - replaces componentDidMount hook. You can have a project
without useState hook but not useEffect hook.
- use to control what happens depending which stage the lifecycle of a component is in.

Why does 
 useEffect(() => {
    console.log('Component Mounted!');
  });
console twice - This is because, the strict mode is enabled to check if we're handling useEffect correctly.

- allows us to execute an action when a component mounts 
Use Cases
- When you want to make API call to get data from somewhere.

UseEffect allows us to handle the mount and update stages concurrently. But if you want to just handle once
eg. Mount, supply an empty array as below
 useEffect(() => {
    console.log('Component Mounted!');
  }, []);
If you want to trigger an action everytime a specific stage changes, supply the state as below.
 useEffect(() => {
    console.log('Component Mounted!');
  }, [text]);

To trigger the third stage, (Unmount) useEffect accepts a return statement.
 useEffect(() => {
    console.log('Component Mounted!');

    return () => {
    console.log('Component Unmounted');
    }
  });

In react 18, UseEffect runs twice, mount and unounts beacuse of strict mode 

APIs to Experiment
1. https://catfact.ninja/fact
2. https://jsonplaceholder.typicode.com/
3. https://api.agify.io/?name=karimi => predict age given name
4. https://excuser-three.vercel.app/ => Generate Excuses

React Router DOM 
- main routing library for react 
npm install react-router-dom
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

BrowserRouter - component used to define where exactly in our app we wnat to have our different routes
Routes can be used to change a specific portion of our app

Route - used to define evry route we want in the app 
<Route path="/" element={} /> - an element is a component to be rendered when a page is loaded

Router - tell react dom thast whatever is inside it can use react dom functionality
- used to define where in your app you want to have access to react dom stuff
wht to put inside router
div>
          <Link to="/">Home</Link>
          <Link to="/menu">Menu</Link>
          <Link to="/contact">Contact</Link>
          <Link to="/about">About</Link>
        </div>
Navbar are to be accessed "globally regardless of the page we're in. Provided by <Link /> component which is part of react dom

React State Mangement
import { createContext, useState } from 'react';
solves - idea of prop drilling 
prop    drilling is the idea of passing prop to a component. The prop wont be used in that component. it's mainpurpose is to be passed down to other comnpinent.
state management is just managing your state to proevent it from becoming messy

createContex Hook - when you have gropus of component that have access to same set of data like a (state, variable or function),
we craete a context of global context to hold all info to pass down. 

global context 

export const 'ContextName' = createContex()
- then wrap it to component that will have access to it
<ContextName.Provider>
....
</ContextName>

React Query
npm install @tanstack/react-query
import { QueryClient } from '@tanstack/react-query';
import { useQuery } from "@tanstack/react-query";

const client = new QueryClient();

- set up at the highest level component 
- allow update data when a user switch tabs - read more on React query
<QueryClientProvider client={client}>
....other components
<QueryClientProvider />

Query client configs
const client = new QueryClient({
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false, //turns off data update whena user switched tabs
      },
    },
  });